<!--Source constants file until I get clarity for environment usage across entire package or if sourcing is enough -->

`r source("../R/package_constants.R")`

<!--` reference1 -->

# Tables {.unnumbered}

ODM version `r pkg.env$dictionary_version_used`.

The ODM database model has 21 tables in its full relational database. The full model is commonly referred to as "long" tables as it stores data with one measurement per row. Each table has mandatory and optional headers.

::: callout-note
## Data storage

It is recommended that all ODM data be stored in the 21 tables as this ensures interoperable data sharing and is supported by the [ODM validation toolkit](https://validate-docs.phes-odm.org "ODM validation toolkit") and other ODM libraries.

However, users have the option to create custom tables or 'views' by combining fields from any table. The common format for data entry is a "wide" format where data is collected with *one day per row* and multiple measures or attributes per row. Please note that this guide does not cover how to generate wide tables.
:::

## Table types

There are three types of tables:

1\) **Regular report tables**. The `measures` and `samples` tables are used for daily reporting of new measurements and information on sample collection. Three tables support regular reporting - `measureSets` is an optional table used to link measures, `sampleRelationships` is an optional table used when samples are pooled or split, and `qualityReports` is used for detailed quality assurance and control measures.

2\) **Contact information tables**. `sites`, `organizations`, `contacts`, and `addresses` hold contact information for the testing site and the person who performed the testing.

3\) **Protocol or methods tables**. The `protocols` and `instruments` tables hold information on the methods used for sample collection or measurement. `protocolSteps` and `protocolRelationships` tables are used in conjunction with the `protocols` table.

4\) **Other report tables**. The `polygons` table stores information on the sample area and the `datasets` table includes information on the data custodian and owner

5\) **Dictionary tables**. `parts`, `sets`, `languages`, and `translations` are reference or look-up tables. For example, the `parts` table describe all elements of the ODM, including tables, table headers, measures, methods, categories, and units are all `parts`. `sets` are collections of parts. For example, units can be grouped together in a `unitSet`. `languages` and `translations` support translations.

The `parts`, `sets`, `languages`, and `translations` tables are reference or lookup tables. For example, the `parts` table describes all elements of the ODM including tables, table headers, measures, methods, categories, and units. The `sets` table is a collection of parts, such as units grouped together in a `unitSet`. The `languages` and `translations` tables support translations.

## Header roles

Each table has column headers, also known as table variables, fields, or entity relationship attributes. The header serves as the top row and contains the variable name.

**Primary key** (PK) - All tables except dictionary tables have a primary key, which serves as a unique identifier for each row in the table. This means that a primary key value cannot be repeated.

**Foreign key** (FK) - Some tables may have one or more foreign keys. A foreign key connects an entry to another table with a primary key. It allows for relationships between tables to be established, making it possible to link data between different tables.

**Header** (header) - This label is used in a table description when a header is not a primary or foreign key.

::: callout-note
## Each table has a primary key

It is important to note that the headers in each table may have different roles, but each header must have one of the three roles described above. The ODM standard requires that each table have a primary key, but the number and type of foreign keys and attributes may vary depending on the table.
:::

## Mandatory, optional, mandatoryIf

A header may be mandatory or optional. In the `measures` table, examples of mandatory headers are the `measureID` and `measurement date`. The ODM validation toolkit can be used to validate data. The toolkit will return an error if a table lacks a mandatory header, or if there are missing row entries for mandatory fields.

`mandatoryIf` headers are special header that are mandatory if special conditions apply. For example, the `protocol steps` table have row entries that are `measures` or `methods`. If the row entry is a `measure`, then a unit becomes mandatory, since all measures must have a unit. So, `units` are `mandatoryIf` in the `Protocol steps` table.

<!--` reference1/ -->

```{r, echo=FALSE, warning=FALSE}
# Can put warning=FALSE above if warnings in display are an issue
# Source utility functions
source("../R/qmd-utils.R")

parts_sheet_name <- "parts"
path_to_excel <- "../data/raw/ODM-dictionary.xlsx"

# Declaring string that will be appended during the loops
table_of_content <- glue::glue('## Table list
                               <ul>')
tables_info_display_content <- ""

parts_table <-
  readxl::read_excel(path_to_excel, sheet = parts_sheet_name)
tables_data <-
  parts_table[parts_table$partType == "table" &
                parts_table$status == "active", ]

has_required_column <- TRUE
for (table_row_index in 1:nrow(tables_data)) {
  single_table_information <- tables_data[table_row_index, ]
  
  # table_ID is assumed to be always present missing ID means invalid part
  table_ID <- single_table_information$partID
  if (is.null(table_ID) ||
      length(table_ID) < 1 || is.na(table_ID)) {
    warning(
      glue::glue(
        'A part with table partType was found but no partID is found. This table will be skipped'
      )
    )
    next()
  }
  
  required_column_name <- glue::glue('{table_ID}Required')
  order_column_name <- glue::glue('{table_ID}Order')
  
  # Append table of contents
  table_of_content <-
    glue::glue(
      '{table_of_content}<li><a href=\"#{single_table_information$partID}\">{single_table_information$partLabel}</a></li>'
    )
  
  # Verify needed column exists
  if (!has_column_for_table(parts_table, table_ID, table_ID)) {
    next()
  }
  
  # Acquire columns that belong to the table
  parts_table[[table_ID]] <-
    tolower(trimws(parts_table[[table_ID]]))
  table_columns <-
    parts_table[parts_table[[table_ID]] == "pk" |
                  parts_table[[table_ID]] == "fk" |
                  parts_table[[table_ID]] == "header",]
  
  # Check for optional columns
  has_required_column <-
    has_column_for_table(parts_table, table_ID, required_column_name)
  if (has_column_for_table(parts_table, table_ID, order_column_name)) {
    table_columns <-
      table_columns[order(table_columns[[order_column_name]]),]
  }
  
  
  # Variables being used in table display
  # Their creation is not needed but I believe it assists in clarity
  table_label <- single_table_information$partLabel
  table_label <-
    modify_and_check_glue_input(table_label, table_ID, "partLabel")
  
  table_description <- single_table_information$partDesc
  table_description <- modify_and_check_glue_input(table_description, table_ID, "partDesc")
  
  table_instruction <- single_table_information$partInstr
  table_instruction <- modify_and_check_glue_input(table_instruction, table_ID, "partInstr")
  
  # Structure of table display
  tables_info_display_content <-
    glue::glue(
      '{tables_info_display_content}
      **{table_label}**<a name=\"{table_ID}\">({table_ID})</a>
      {table_description} {table_instruction}<ul>',
      .null = "Missing"
    )
  
  for (column_row_index in 1:nrow(table_columns)) {
    column_row <- table_columns[column_row_index, ]
    
    tmp_key_type <- column_row[[table_ID]]
    if (length(tmp_key_type) > 0 && !is.na(tmp_key_type)) {
      if (tolower(tmp_key_type) == "fk") {
        tmp_key_type <- "Foreign Key"
      } else if (tolower(tmp_key_type) == "pk") {
        tmp_key_type <- "Primary Key"
      } else if (tolower(tmp_key_type) == "header") {
        tmp_key_type <- "Header"
      } else {
        next()
      }
    }
    
    # Column_ID is assumed to be always present missing ID means invalid part
    column_ID <- column_row$partID
    if (is.null(column_ID) ||
        length(column_ID) < 1 || is.na(column_ID)) {
      warning(
        glue::glue(
          '{table_ID} contains a missing id for one of its columns. Missing columns are skipped'
        )
      )
      next()
    }
    
    # Variables being used in column display
    column_label <- column_row$partLabel
    column_label <-
      modify_and_check_glue_input(column_label, column_ID, "partLabel")
    
    column_description <- column_row$partDesc
    column_description <-
      modify_and_check_glue_input(column_description, column_ID, "partDesc")
    
    column_requirement <- ""
    if (has_required_column) {
      column_requirement <- column_row[[required_column_name]]
      column_requirement <-
        modify_and_check_glue_input(column_requirement, column_ID, required_column_name)
      # Moving comma insertion here to allow for smoother output
      if (column_requirement != "") {
        column_requirement <- glue::glue(', {column_requirement}')
      }
    }
    
    column_dataType <- column_row$dataType
    column_dataType <-
      modify_and_check_glue_input(column_dataType, column_ID, "dataType")
    
    # Structure of column display
    tables_info_display_content <-
      glue::glue(
        '{tables_info_display_content}<li>**{column_label}** (partID: {column_ID}). {column_description} Role: {tmp_key_type}{column_requirement}. Data type: {column_dataType}.'
      )
    
    # Append link to catSetID if dataType is categorical
    if (column_dataType == "categorical") {
      column_catSetID <- column_row$catSetID
      column_catSetID <-
        modify_and_check_glue_input(column_catSetID, table_ID, "catSetID")
      if (nchar(column_catSetID) > 1) {
        tables_info_display_content <-
          glue::glue(
            '{tables_info_display_content} CatSet: <a href=\"/sets.html/#{column_catSetID}\">{column_catSetID}</a>'
          )
      }
    }
    
    # Close off column list element
    tables_info_display_content <-
      glue::glue('{tables_info_display_content}</li>')
  }
  tables_info_display_content <-
    glue::glue('{tables_info_display_content}</ul>')
}
table_of_content <- glue::glue('{table_of_content}</ul>')
```

`r table_of_content` `r tables_info_display_content`

Page created on `r format(Sys.Date(), "%c")`.
