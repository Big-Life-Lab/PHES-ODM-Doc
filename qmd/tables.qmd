<!--Source constants file until I get clarity for environment usage across entire package or if sourcing is enough -->

`r source("../R/package_constants.R")`

<!--` reference1 -->

# Tables {.unnumbered}

The list of tables below are for ODM version `r pkg.env$dictionary_version_used`.

There are 21 tables in the ODM.<!--# I've added explanatory text. This text should be moved to our explanatory documents, but I've placed here as a temporary solution until we generate those documents. -->

Users can customize the tables for different purposes. The format of the tables in this reference document is for the full relational database model. The comprehensive list of tables includes all mandatory and optional headers. The table format is used for drata storage and they are informally described as "long" tables with one measure, method or attribute for each row.

Users can modify or create their own table format for data entry, analyses, or reporting. Commonly, these tables are a "wide" format where there is one day per row and multiple measures or attributes per row. How to generate wide tables is not included in this section.

There are three types of tables:

1\) **Regular report tables**. The `measues` and `samples` tables are used day-to-day reporting of new measurements and information about how and when samples are collected.

Three tables support regular reporting. `measureSets` is an optional table that can be used to link measures together. `sampleRelationships` is also optional and used only when you have samples that are pooled or split. `qualityReports` is used for detailed quality assurance and control measures.

2\) **Contact information tables**. `sites`, `organizations`, `contacts`, and `addresses` hold contact information where testing was performed and who performed testing.

3\) **Protocol or methods tables**. `protocols` and `instruments` are where you record information about the methods used to perform sample, or make measurements or observations. how samples are taken and measures are reported. `protocolSteps` and `protocolRelationships`tables are part used alongside the `protocols` table.

4\) **Other report tables**. These tables include `polygons` where information is store about the sample shed and `datasets` which includes information about the data custodian and owner of the data.

5\) **Dictionary tables**. `parts`, `sets`, `languages`, and `translations` these tables....

<!--` reference1/ -->

```{r, echo=FALSE}
# Source utility functions
source("../R/qmd-utils.R")

parts_sheet_name <- "parts"
path_to_excel <- "../data/raw/ODM-dictionary.xlsx"

# Declaring string that will be appended during the loops
table_of_content <- glue::glue('# Table of Contents
                               <ul>') 
tables_info_display_content <- ""

parts_table <- readxl::read_excel(path_to_excel, sheet = parts_sheet_name)
tables_data <- parts_table[parts_table$partType=="table" & parts_table$status=="active", ]

present_column_required_information <- TRUE
for (table_row_index in 1:nrow(tables_data)) {
  single_table_information <- tables_data[table_row_index, ]
  
 # table_ID is assumed to be always present missing ID means invalid part
  table_ID <- single_table_information$partID
  if (is.null(table_ID) || length(table_ID) < 1) {
    warning(
      glue::glue(
        'A part with table partType was found but no partID is found. This table will be skipped'
      )
    )
    next()
  }
  
  required_column_name <- glue::glue('{table_ID}Required')
  order_column_name <- glue::glue('{table_ID}Order')
  
  # Append table of contents
  table_of_content <- glue::glue('{table_of_content}<li><a href=\"#{single_table_information$partID}\">{single_table_information$partLabel}</a></li>')
  
  # Verify needed column exists
  if(!has_column_for_table(parts_table, table_ID, table_ID)){
    next()
  }
  
  # Acquire columns that belong to the table
  parts_table[[table_ID]] <- tolower(trimws(parts_table[[table_ID]]))
  table_columns <-
    parts_table[parts_table[[table_ID]] == "pk" |
                  parts_table[[table_ID]] == "fk" |
                  parts_table[[table_ID]] == "header",]
  
  # Check for optional columns
  if (has_column_for_table(parts_table, table_ID, required_column_name)) {
    present_column_required_information <- TRUE
  } else{
    present_column_required_information <- FALSE
  }
  if (has_column_for_table(parts_table, table_ID, order_column_name)) {
    table_columns <-
      table_columns[order(table_columns[[order_column_name]]),]
  }
  
  
  # Variables being used in table display
  # Their creation is not needed but I believe it assists in clarity
  table_label <- single_table_information$partLabel
  table_label <- modify_and_check_glue_input(table_label, table_ID, "partLabel")
  
  table_description <- single_table_information$partDesc
  table_instruction <- single_table_information$partInstr
  
  # Structure of table display
  tables_info_display_content <- glue::glue('{tables_info_display_content}
                                            **{table_label}**<a name=\"{table_ID}\">({table_ID})</a>
                                            {table_description} {table_instruction}
                                            <ul>', .null = "Missing")
  
  for (column_row_index in 1:nrow(table_columns)) {
    column_row <- table_columns[column_row_index, ]
    
    tmp_key_type <- column_row[[table_ID]]
    if(length(tmp_key_type)>0&&!is.na(tmp_key_type)) {
      if (tolower(tmp_key_type) == "fk") {
        tmp_key_type <- "Foreign Key"
      } else if (tolower(tmp_key_type) == "pk") {
        tmp_key_type <- "Primary Key"
      } else if(tolower(tmp_key_type) == "header"){
        tmp_key_type <- "Header"
      }else {
        next()
      }
    }
    
    # Column_ID is assumed to be always present missing ID means invalid part
    column_ID <- column_row$partID
    if(is.null(column_ID) || length(column_ID)<1){
      warning(glue::glue('{table_ID} contains a missing id for one of its columns. Missing columns are skipped'))
      next()
    }
    
    # Variables being used in column display
    column_label <- column_row$partLabel
    column_label <- modify_and_check_glue_input(column_label, column_ID, "partLabel")
    
    column_description <- column_row$partDesc
    column_description <- modify_and_check_glue_input(column_description, column_ID, "partDesc")
    
    column_requirement <- column_row[[required_column_name]]
    column_requirement <- modify_and_check_glue_input(column_requirement, column_ID, required_column_name)
    
    column_dataType <- column_row$dataType
    column_dataType <- modify_and_check_glue_input(column_dataType, column_ID, "dataType")
    
    # Structure of column display
    tables_info_display_content <- glue::glue('{tables_info_display_content}<li>**{column_label}** (partID: {column_ID}). {column_description} Role: {tmp_key_type}, {column_requirement}. Data type: {column_dataType}.')
    
    # Append link to catSetID if dataType is categorical
    if(column_dataType =="categorical"){
      column_catSetID <- column_row$catSetID
      tables_info_display_content <- glue::glue('{tables_info_display_content}
                                                catSet: <a href=\"/sets.html/#{column_catSetID}\">{column_catSetID}</a>')
    }
    
    # Close off column list element
    tables_info_display_content <- glue::glue('{tables_info_display_content}</li>')
  }
  tables_info_display_content <- glue::glue('{tables_info_display_content}</ul>')
}
table_of_content <- glue::glue('{table_of_content}</ul>')
```


`r table_of_content` `r tables_info_display_content`


Page created on `r format(Sys.Date(), "%c")`, using document generator version 0.1.
