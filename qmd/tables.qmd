<!--Source constants file until I get clarity for environment usage across entire package or if sourcing is enough -->

`r source("../R/package_constants.R")`

<!--` reference1 -->

# Tables {.unnumbered}

The list of tables below are for ODM version `r pkg.env$dictionary_version_used`.

There are 21 tables in the ODM.<!--# I've added explanatory text. This text should be moved to our explanatory documents, but I've placed here as a temporary solution until we generate those documents. -->

Users can customize the tables for different purposes. The format of the tables in this reference document is for the full relational database model. The comprehensive list of tables includes all mandatory and optional headers. The table format is used for drata storage and they are informally described as "long" tables with one measure, method or attribute for each row.

Users can modify or create their own table format for data entry, analyses, or reporting. Commonly, these tables are a "wide" format where there is one day per row and multiple measures or attributes per row. How to generate wide tables is not included in this section.

There are three types of tables:

1\) **Regular report tables**. The `measues` and `samples` tables are used day-to-day reporting of new measurements and information about how and when samples are collected.

Three tables support regular reporting. `measureSets` is an optional table that can be used to link measures together. `sampleRelationships` is also optional and used only when you have samples that are pooled or split. `qualityReports` is used for detailed quality assurance and control measures.

2\) **Contact information tables**. `sites`, `organizations`, `contacts`, and `addresses` hold contact information where testing was performed and who performed testing.

3\) **Protocol or methods tables**. `protocols` and `instruments` are where you record information about the methods used to perform sample, or make measurements or observations. how samples are taken and measures are reported. `protocolSteps` and `protocolRelationships`tables are part used alongside the `protocols` table.

4\) **Other report tables**. These tables include `polygons` where information is store about the sample shed and `datasets` which includes information about the data custodian and owner of the data.

5\) **Dictionary tables**. `parts`, `sets`, `languages`, and `translations` these tables....

<!--` reference1/ -->

```{r, echo=FALSE}
# Source utility functions
source("../R/qmd-utils.R")

parts_sheet_name <- "parts"
path_to_excel <- "../data/raw/ODM-dictionary.xlsx"

# Declaring string that will be appended during the loops
table_of_content <- glue::glue('# Table of Contents
                               <ul>') 
tables_info_display_content <- ""

parts_table <- readxl::read_excel(path_to_excel, sheet = parts_sheet_name)
tables_data <- parts_table[parts_table$partType=="table" & parts_table$status=="active", ]

present_column_required_information <- TRUE
for (table_row_index in 1:nrow(tables_data)) {
  single_table_information <- tables_data[table_row_index, ]
  
  table_name <- trimws(single_table_information$partID)
  if(length(tables_info_display_content)<1){
    print(table_name)
  }
  # Verify existing table name
  if(length(table_name)<1 || trimws(table_name)==""){
    warning("Found an empty partID with partType of table")
    next()
  }
  
  required_column_name <- glue::glue('{table_name}Required')
  order_column_name <- glue::glue('{table_name}Order')
  
  # Append table of contents
  table_of_content <- glue::glue('{table_of_content}<li><a href=\"#{single_table_information$partID}\">{single_table_information$partLabel}</a></li>')
  
  # Verify needed column exists
  if(!has_column_for_table(parts_table, table_name, table_name)){
    next()
  }
  
  # Aquire columns that belong to the table
  table_columns <- parts_table[parts_table[[table_name]]=="pk" | parts_table[[table_name]]=="fk" | parts_table[[table_name]]=="header", ]
  
  # Check for optional columns
  if(has_column_for_table(parts_table, table_name, required_column_name)){
    present_column_required_information <- TRUE
  }else{
    present_column_required_information <- FALSE
  }
  if(has_column_for_table(parts_table, table_name, order_column_name)){
    table_columns <- table_columns[order(table_columns[[order_column_name]]), ]
  }
  
  # Verify table information @RUSTY FUNCTION THIS OUT ASAP
  table_label <- single_table_information$partLabel
  table_ID <- single_table_information$partID
  table_description <- single_table_information$partDesc
  table_instruction <- single_table_information$partInstr
  if(length(table_label)<0) {
    table_label <- "Label Missing"
  }
  if (length(table_ID) < 0) {
    table_ID <- "ID Missing"
  }
  if (length(table_description) < 0) {
    table_description <- "Description Missing"
  }
  if (length(table_instruction) < 0) {
    table_instruction <- "Instuctions Missing"
  }
  
  
  # Add table information and start list creation
  tables_info_display_content <- glue::glue('{tables_info_display_content}
                                            **{table_label}**<a name=\"{table_ID}\">({table_ID})</a>
                                            {table_description} {table_instruction}
                                            <ul>')
  
  for (column_row_index in 1:nrow(table_columns)) {
    column_row <- table_columns[column_row_index, ]
    
    tmp_key_type <- column_row[[table_name]]
    if(length(tmp_key_type)>0&&!is.na(tmp_key_type)) {
      if (tolower(tmp_key_type) == "fk") {
        tmp_key_type <- "Foreign Key"
      } else if (tolower(tmp_key_type) == "pk") {
        tmp_key_type <- "Primary Key"
      } else if(tolower(tmp_key_type) == "header"){
        tmp_key_type <- "Header"
      }else {
        next()
      }
    }
    
    # Verify glue inputs @RUSTY FUNCTION THIS OUT
    column_label <- column_row$partLabel
    column_ID <- column_row$partID
    column_description <- column_row$partDesc
    column_requirement <- column_row[[required_column_name]]
    column_dataType <- column_row$dataType
      
    if(length(column_label)<0){
      column_label <- "Label Missing"
    }
    if(length(column_ID)<0){
      column_ID <- "ID Missing"
    }
    if(length(column_description)<0){
      column_description <- "Description Missing"
    }
    if(length(column_requirement)<0||is.null(column_requirement)){
      column_requirement <- "Requirement Missing"
    }
    if(length(column_dataType)<0){
      column_dataType <- "Data type Missing"
    }
    
    # Structure of column display
    tables_info_display_content <- glue::glue('{tables_info_display_content}<li>**{column_label}** (partID: {column_ID}). {column_description} Role: {tmp_key_type}, {column_requirement}. Data type: {column_dataType}</li>')
  }
  tables_info_display_content <- glue::glue('{tables_info_display_content}</ul>')
}
table_of_content <- glue::glue('{table_of_content}</ul>')
```


`r table_of_content` `r tables_info_display_content`


Page created on `r format(Sys.Date(), "%c")`, using document generator version 0.1.
