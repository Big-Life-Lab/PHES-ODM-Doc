<!--Source constants file until I get clarity for environment usage across entire package or if sourcing is enough -->

`r source("../R/package_constants.R")`

<!--` reference1 -->

# Tables {.unnumbered}

ODM version `r pkg.env$dictionary_version_used`.

The ODM has 21 tables in the full relational database model. The full relationship model is informally described as "long" tables because it stores data with *one measure per row*. Within each table, there are mandatory and optional headers.

::: callout-note
## Table support

It is recommended that all ODM data is stored in the 21 tables. Storing data in the recommended tables allows interoperable data sharing and is supported with [ODM validation toolkit](https://validate-docs.phes-odm.org "ODM validation toolkit") and other ODM libraries.

That stated, users can create custom tables or 'views' that mix and match fields from any table. A common format for data entry is a "wide" format, where data is collected as *one day per row* with multiple measures or attributes per row. How to generate wide tables is not included in this section.
:::

## Table types

There are three types of tables:

1\) **Regular report tables**. The `measues` and `samples` tables are used day-to-day reporting of new measurements and information about how and when samples are collected.

Three tables support regular reporting. `measureSets` is an optional table that can be used to link measures together. `sampleRelationships` is also optional and used only when you have samples that are pooled or split. `qualityReports` is used for detailed quality assurance and control measures.

2\) **Contact information tables**. `sites`, `organizations`, `contacts`, and `addresses` hold contact information where testing was performed and who performed testing.

3\) **Protocol or methods tables**. `protocols` and `instruments` are where you record information about the methods used to perform sample, or make measurements or observations. how samples are taken and measures are reported. `protocolSteps` and `protocolRelationships`tables are part used alongside the `protocols` table.

4\) **Other report tables**. `polygons` where information is store about the sample shed and `datasets` which includes information about the data custodian and owner of the data.

5\) **Dictionary tables**. `parts`, `sets`, `languages`, and `translations` are reference or look-up tables. For example, the `parts` table describe all elements of the ODM, including tables, table headers, measures, methods, categories, and units are all `parts`. `sets` are collections of parts. For example, units can be grouped together in a `unitSet`. `languages` and `translations` support translations.

## Header roles

Tables have column header, also known as a table variable, field, or entity relationship 'attribute'. A header is the top row or the variable name in a table.

Each header has a label for one of three roles.

**Primary key** (PK) - All tables, except dictionary tables, have a primary key. A primary key serves as the unique identifier for row entries for the table. This means a primary key value cannot be repeated in a table.

**Foreign key** (FK) - Tables may have one or more foreign keys. A foreign key connects an entry to another table that holds an entry (row) with a primary key.

**Header** (header) - The label 'header' in a table description when a header is not a primary or foreign key.

## Mandatory, optional, mandatoryIf

A header may be mandatory or optional. In the `Measures` table, examples of mandatory headers are the `measureID` and `measurement date`. The ODM validation toolkit can be used to validate data. The toolkit will return an error if a table lacks a mandatory header, or if there are missing row entries for mandatory fields.

`mandatoryIf` headers are special header that are mandatory if special conditions apply. For example, the `Protocol steps` table have row entries that are `measures` or `methods`. If the row entry is a `measure`, then a `unit` becomes mandatory, since all measures must have a unit. So, units are `mandatoryIf` in the protocol table.

<!--` reference1/ -->

```{r, echo=FALSE, warning=FALSE}
# Can put warning=FALSE above if warnings in display are an issue
# Source utility functions
source("../R/qmd-utils.R")

parts_sheet_name <- "parts"
path_to_excel <- "../data/raw/ODM-dictionary.xlsx"

# Declaring string that will be appended during the loops
table_of_content <- glue::glue('## Table list
                               <ul>')
tables_info_display_content <- ""

parts_table <-
  readxl::read_excel(path_to_excel, sheet = parts_sheet_name)
tables_data <-
  parts_table[parts_table$partType == "table" &
                parts_table$status == "active", ]

has_required_column <- TRUE
for (table_row_index in 1:nrow(tables_data)) {
  single_table_information <- tables_data[table_row_index, ]
  
  # table_ID is assumed to be always present missing ID means invalid part
  table_ID <- single_table_information$partID
  if (is.null(table_ID) ||
      length(table_ID) < 1 || is.na(table_ID)) {
    warning(
      glue::glue(
        'A part with table partType was found but no partID is found. This table will be skipped'
      )
    )
    next()
  }
  
  required_column_name <- glue::glue('{table_ID}Required')
  order_column_name <- glue::glue('{table_ID}Order')
  
  # Append table of contents
  table_of_content <-
    glue::glue(
      '{table_of_content}<li><a href=\"#{single_table_information$partID}\">{single_table_information$partLabel}</a></li>'
    )
  
  # Verify needed column exists
  if (!has_column_for_table(parts_table, table_ID, table_ID)) {
    next()
  }
  
  # Acquire columns that belong to the table
  parts_table[[table_ID]] <-
    tolower(trimws(parts_table[[table_ID]]))
  table_columns <-
    parts_table[parts_table[[table_ID]] == "pk" |
                  parts_table[[table_ID]] == "fk" |
                  parts_table[[table_ID]] == "header",]
  
  # Check for optional columns
  has_required_column <-
    has_column_for_table(parts_table, table_ID, required_column_name)
  if (has_column_for_table(parts_table, table_ID, order_column_name)) {
    table_columns <-
      table_columns[order(table_columns[[order_column_name]]),]
  }
  
  
  # Variables being used in table display
  # Their creation is not needed but I believe it assists in clarity
  table_label <- single_table_information$partLabel
  table_label <-
    modify_and_check_glue_input(table_label, table_ID, "partLabel")
  
  table_description <- single_table_information$partDesc
  table_description <- modify_and_check_glue_input(table_description, table_ID, "partDesc")
  
  table_instruction <- single_table_information$partInstr
  table_instruction <- modify_and_check_glue_input(table_instruction, table_ID, "partInstr")
  
  # Structure of table display
  tables_info_display_content <-
    glue::glue(
      '{tables_info_display_content}
      **{table_label}** <a name=\"{table_ID}\"></a>(<a href=\"/parts.html#{table_ID}\">{table_ID}</a>)
      {table_description} {table_instruction}<ul>',
      .null = "Missing"
    )
  
  for (column_row_index in 1:nrow(table_columns)) {
    column_row <- table_columns[column_row_index, ]
    
    tmp_key_type <- column_row[[table_ID]]
    if (length(tmp_key_type) > 0 && !is.na(tmp_key_type)) {
      if (tolower(tmp_key_type) == "fk") {
        tmp_key_type <- "Foreign Key"
      } else if (tolower(tmp_key_type) == "pk") {
        tmp_key_type <- "Primary Key"
      } else if (tolower(tmp_key_type) == "header") {
        tmp_key_type <- "Header"
      } else {
        next()
      }
    }
    
    # Column_ID is assumed to be always present missing ID means invalid part
    column_ID <- column_row$partID
    if (is.null(column_ID) ||
        length(column_ID) < 1 || is.na(column_ID)) {
      warning(
        glue::glue(
          '{table_ID} contains a missing id for one of its columns. Missing columns are skipped'
        )
      )
      next()
    }
    
    # Variables being used in column display
    column_label <- column_row$partLabel
    column_label <-
      modify_and_check_glue_input(column_label, column_ID, "partLabel")
    
    column_description <- column_row$partDesc
    column_description <-
      modify_and_check_glue_input(column_description, column_ID, "partDesc")
    
    column_requirement <- ""
    if (has_required_column) {
      column_requirement <- column_row[[required_column_name]]
      column_requirement <-
        modify_and_check_glue_input(column_requirement, column_ID, required_column_name)
      # Moving comma insertion here to allow for smoother output
      if (column_requirement != "") {
        column_requirement <- glue::glue(', {column_requirement}')
      }
    }
    
    column_dataType <- column_row$dataType
    column_dataType <-
      modify_and_check_glue_input(column_dataType, column_ID, "dataType")
    
    # Structure of column display
    tables_info_display_content <-
      glue::glue(
        '{tables_info_display_content}<li>**{column_label}** (partID: <a href=\"/parts.html#{column_ID}\">{column_ID}</a>). {column_description} Role: {tmp_key_type}{column_requirement}. Data type: {column_dataType}.'
      )
    
    # Append link to catSetID if dataType is categorical
    if (column_dataType == "categorical") {
      column_catSetID <- column_row$catSetID
      column_catSetID <-
        modify_and_check_glue_input(column_catSetID, table_ID, "catSetID")
      if (nchar(column_catSetID) > 1) {
        tables_info_display_content <-
          glue::glue(
            '{tables_info_display_content} CatSet: <a href=\"/sets.html#{column_catSetID}\">{column_catSetID}</a>'
          )
      }
    }
    
    # Close off column list element
    tables_info_display_content <-
      glue::glue('{tables_info_display_content}</li>')
  }
  tables_info_display_content <-
    glue::glue('{tables_info_display_content}</ul>')
}
table_of_content <- glue::glue('{table_of_content}</ul>')
```

`r table_of_content` `r tables_info_display_content`

Page created on `r format(Sys.Date(), "%c")`.
