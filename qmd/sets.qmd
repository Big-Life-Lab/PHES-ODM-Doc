---
project:
  execute-dir: ../
---
```{r setup, echo=FALSE}
knitr::opts_knit$set(root.dir = normalizePath("../"))
```

# Sets {.unnumbered}
{{< include _dictionary-version.qmd >}}

The list of sets in aphabetical order of setsID


```{r, echo=FALSE, warning=FALSE}
# Utility Functions
# Source utility functions
source("R/qmd-utils.R")
# Source table formatting
source("R/format-table.R")

handle_empty_character_vector <-
  function(check_vector, replace_string) {
    if (length(check_vector) < 1) {
      return(replace_string)
    }else{
      return(check_vector)
    }
  }

list_creation <- function(string_to_append, list_values){
  string_to_append <- glue::glue('{string_to_append} 
                                 <ul>', .null = "NA")
  for (list_element in list_values) {
    string_to_append <- glue::glue('{string_to_append} 
                                   <li> {list_element} </li>', .null = "NA")
  }
  string_to_append <- glue::glue('{string_to_append} 
                                 </ul>', .null = "NA")
  return(string_to_append)
}

# Generate, format and order sets table
sets_table_source <- readxl::read_excel(file.path(getwd(),constants$dictionary_directory, dictionary_full_file_name),
                     sheet = constants$sets_sheet_name)
sets_table <- format_table(sets_table_source)
sets_table <- sets_table[order(sets_table[[sets_sheet_column_names$part_set_type_column_name]]), ]

# Generate and format parts table
parts_table_source <-
  readxl::read_excel(file.path(getwd(),constants$dictionary_directory, dictionary_full_file_name),
                     sheet = constants$parts_sheet_name)
parts_table <- format_table(parts_table_source, parts_sheet_column_names)

display_content <- ""


# Find and loop over unique setTypes
unique_set_types <-
  unique(sets_table[[sets_sheet_column_names$part_set_type_column_name]])
for (set_type in unique_set_types) {
  # Create header for setType
  set_type_info <-
    parts_table[parts_table[[parts_sheet_column_names$part_ID_column_name]] == set_type, ]
  if(nrow(set_type_info)<1){
        warning(glue::glue('{set_type} has no valid set info'))
        next()
      }
  set_type_label <-
    set_type_info[[parts_sheet_column_names$part_label_column_name]]
  set_type_instruction <-
    set_type_info[[parts_sheet_column_names$part_instruction_column_name]]
  
  
  display_content <- glue::glue('{display_content}
                              ## {set_type_label} {{ #{set_type} }}
                              ({set_type})
                                {set_type_instruction}
                              ', .null = "NA")
  
  # Find and loop over unique setID according to set_type
  rows_for_current_set_type <- sets_table[sets_table[[sets_sheet_column_names$part_set_type_column_name]] == set_type,]
  unique_set_IDs <- unique(rows_for_current_set_type[[sets_sheet_column_names$part_set_ID_column_name]])
  for (set_ID in unique_set_IDs) {
    # Create set_ID subsection
    display_content <- glue::glue('{display_content}
    
                                ### {set_ID} 
                                set members:', .null = "NA")
    list_values <- list()
    
    # Find and loop over unique partID according to set_ID
    current_set_ID_rows <- rows_for_current_set_type[rows_for_current_set_type[[sets_sheet_column_names$part_set_ID_column_name]] == set_ID,]
    unique_part_IDs <- unique(current_set_ID_rows[[parts_sheet_column_names$part_ID_column_name]])
    for (part_ID in unique_part_IDs) {
      part_info <- parts_table[parts_table[[parts_sheet_column_names$part_ID_column_name]] == part_ID,]
      if(nrow(part_info)<1){
        warning(glue::glue('{part_ID} has no valid part info'))
        next()
      }
      part_label <- part_info[[parts_sheet_column_names$part_label_column_name]]
      
      list_values[[length(list_values)+1]] <- glue::glue('{part_label}({part_ID})', .null = "NA")
      
    }
    display_content <- list_creation(display_content, list_values)
  }
}


```

`r display_content`
