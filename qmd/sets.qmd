---
project:
  execute-dir: ../
---

```{r setup, echo=FALSE}
knitr::opts_knit$set(root.dir = normalizePath("../"))
```

# Sets {.unnumbered}

{{< include _dictionary-version.qmd >}}

Sets are lists of categories and other parts. For example, `Collection category set` ([collectionCatSet](file:///Users/dmanuel/github/PHES-ODM-Doc/docs/sets.html#collectCatSet)) contains a list of the different collection types including: `Moore swab`, `Grab sample`, `Flow proportional sample`, etc.

Sets can have parts that are reused. For example, there are different quality measures for sample collection (e.g. `Sample not collected`), PCR measures (`Inhibition preset`), and sequencing measures (`Low depth of coverage`), but all quality sets share the `No quality concerns` indicator.

```{r, echo=FALSE, warning=FALSE}
# Utility Functions
# Source utility functions
source("R/qmd-utils.R")
# Source table formatting
source("R/format-table.R")

# Extract, format and order sets table on set type
sets_table_source <-
  readxl::read_excel(
    file.path(
      getwd(),
      constants$dictionary_directory,
      dictionary_full_file_name
    ),
    sheet = constants$sets_sheet_name
  )
sets_table <- format_table(sets_table_source)
sets_table <-
  sets_table[order(sets_table[[sets_sheet_column_names$part_set_type_column_name]]),]

# Generate and format parts table
parts_table_source <-
  readxl::read_excel(
    file.path(
      getwd(),
      constants$dictionary_directory,
      dictionary_full_file_name
    ),
    sheet = constants$parts_sheet_name
  )
parts_table <-
  format_table(parts_table_source,
               parts_sheet_column_names,
               remove_duplicate = TRUE)

# Declare list to store sets
sets_list <- list()

# Find then loop over unique setTypes
unique_set_types <-
  unique(sets_table[[sets_sheet_column_names$part_set_type_column_name]])
for (set_type in unique_set_types) {
  # Removing dictSet set type and catSet
  if (set_type == constants$set_type_is_dictSet || set_type == constants$set_type_is_catSet) {
    next()
  }
  
  # Create header for setType
  set_type_info <-
    parts_table[parts_table[[parts_sheet_column_names$part_ID_column_name]] == set_type,]
  # Issue warning and skip if no matching information on setType is found in parts
  if (nrow(set_type_info) < 1) {
    warning(glue::glue('{set_type} has no valid set info and is skipped'))
    next()
  }
  set_type_label <-
    set_type_info[[parts_sheet_column_names$part_label_column_name]]
  verify_input(set_type_label,
               glue::glue('Set type label is missing for {set_type}'))
  set_type_instruction <-
    set_type_info[[parts_sheet_column_names$part_instruction_column_name]]
  verify_input(
    set_type_instruction,
    glue::glue('Set type instructions are missing for {set_type}')
  )
  set_type_description <-
    set_type_info[[parts_sheet_column_names$part_description_column_name]]
  verify_input(set_type_description,
               glue::glue('Set type description is missing for {set_type}'))
  
  set_display <- glue::glue(
    '## {set_type_label} {{ #{set_type} }}
                              <a href=\"/parts.html#{set_type}\">({set_type})</a>. {set_type_description} {if (set_type_instruction %!=na% constants$dictionary_missing_value_replacement) set_type_instruction else "" }')
  
  # Find and loop over unique setID according to set_type
  rows_for_current_set_type <-
    sets_table[sets_table[[sets_sheet_column_names$part_set_type_column_name]] == set_type, ]
  unique_set_IDs <-
    unique(rows_for_current_set_type[[sets_sheet_column_names$part_set_ID_column_name]])
  unique_set_IDs <- sort(unique_set_IDs)
  for (set_ID in unique_set_IDs) {
    set_ID_info <-
      parts_table[parts_table[[parts_sheet_column_names$part_ID_column_name]] == set_ID,]
    # Handle no rows found for set_ID in parts
    if (nrow(set_ID_info) < 1) {
      warning(glue::glue('Set ID:{set_ID} has no data in parts sheet and is skipped'))
      next()
    }
    set_ID_part_label <-
      set_ID_info[[parts_sheet_column_names$part_label_column_name]]
    # Create set_ID subsection
    set_display <- verify_and_append_content(
      set_display,
      set_ID_part_label,
      glue::glue(
        'Set ID: {set_ID} has no valid {parts_sheet_column_names$part_label_column_name}'
      ),
      glue::glue('\n\n
      ### {set_ID_part_label} {{ #{set_ID} }}'),
      glue::glue('\n\n
                 ### {set_ID}')
    )
    # Declare additional setID display
    set_ID_part_description <- set_ID_info[[parts_sheet_column_names$part_description_column_name]]
    set_ID_part_instruction <- set_ID_info[[parts_sheet_column_names$part_instruction_column_name]]
    set_ID_part_status <- set_ID_info[[parts_sheet_column_names$part_status_column_name]]
    set_ID_part_first_released <- set_ID_info[[parts_sheet_column_names$part_first_release_column_name]]
    set_ID_part_last_updated <- set_ID_info[[parts_sheet_column_names$part_last_updated_column_name]]
    
    # Verify display elements
    verify_input(set_ID_part_description,
                 glue::glue('Part description is missing for {set_ID}'))
    verify_input(set_ID_part_instruction,
                 glue::glue('Part instruction is missing for {set_ID}'))
    verify_input(set_ID_part_status,
                 glue::glue('Part status is missing for {set_ID}'))
    verify_input(set_ID_part_first_released,
                 glue::glue('Part first released is missing for {set_ID}'))
    verify_input(set_ID_part_last_updated,
                 glue::glue('Part last updates is missing for {set_ID}'))
    
    set_display <- glue::glue(
      '{set_display}
<a href=\"/parts.html#{set_ID}\">({set_ID})</a>{set_ID_part_description} \\
{if(set_ID_part_instruction %!=na% constants$dictionary_missing_value_replacement) set_ID_part_instruction else ""} </br>
Status: {set_ID_part_status}. First Released: {set_ID_part_first_released}. \\
Last updated: {set_ID_part_last_updated}.'
    )
    
    # Create list to hold a values for html list
    list_values <- list()
    
    # Find and loop over unique partID according to set_ID
    current_set_ID_rows <-
      rows_for_current_set_type[rows_for_current_set_type[[sets_sheet_column_names$part_set_ID_column_name]] == set_ID, ]
    unique_part_IDs <-
      unique(current_set_ID_rows[[parts_sheet_column_names$part_ID_column_name]])
    unique_part_IDs <- sort(unique_part_IDs)
    for (part_ID in unique_part_IDs) {
      part_info <-
        parts_table[parts_table[[parts_sheet_column_names$part_ID_column_name]] == part_ID, ]
      # Verify that parts contains the requested part information
      if (nrow(part_info) < 1) {
        warning(
          glue::glue(
            '{part_ID} part in {set_ID} set for {set_type} set type has no valid part info and is skipped'
          )
        )
        next()
      }
      # Declare display elements
      part_label <-
        part_info[[parts_sheet_column_names$part_label_column_name]]
      part_description <-
        part_info[[parts_sheet_column_names$part_description_column_name]]
      part_status <-
        part_info[[parts_sheet_column_names$part_status_column_name]]
      part_first_released <-
        part_info[[parts_sheet_column_names$part_first_release_column_name]]
      part_last_updated <-
        part_info[[parts_sheet_column_names$part_last_updated_column_name]]
      
      # Verify display elements
      verify_input(part_label,
                   glue::glue('Part label is missing for {part_ID}'))
      verify_input(part_description,
                   glue::glue('Part description is missing for {part_ID}'))
      verify_input(part_status,
                   glue::glue('Part status is missing for {part_ID}'))
      verify_input(part_first_released,
                   glue::glue('Part first released is missing for {part_ID}'))
      verify_input(part_last_updated,
                   glue::glue('Part last updates is missing for {part_ID}'))
      
      list_values[[length(list_values) + 1]] <-
        glue::glue(
          '**{part_label}** <a href=\"/parts.html#{part_ID}\">({part_ID})</a>. {part_description} </br>Status: {part_status}. First released: {part_first_released}. Last updated: {part_last_updated}.')
      
    }
    set_display <- create_html_list(set_display, list_values)
  }
  sets_list[[set_type]] <- set_display
}

# Create lists
list_set_rows <-
  sets_table[sets_table[[sets_sheet_column_names$part_set_ID_column_name]] == constants$set_ID_is_list_set,]
unique_list_part_IDs <-
  unique(list_set_rows[[parts_sheet_column_names$part_ID_column_name]])

# Create list to store lists
list_of_lists <- list()

for (list_ID in unique_list_part_IDs) {
  list_info_row <-
    parts_table[parts_table[[parts_sheet_column_names$part_ID_column_name]] ==
                  list_ID,]
  # Verify that parts contains the requested part information
  if (nrow(list_info_row) < 1) {
    warning(glue::glue('{list_ID} has no valid part info and is skipped'))
    next()
  }
  list_label <-
    list_info_row[[parts_sheet_column_names$part_label_column_name]]
  verify_input(list_label, glue::glue('List label is missing for {list_ID}'))
  list_instruction <-
    list_info_row[[parts_sheet_column_names$part_instruction_column_name]]
  verify_input(list_instruction,
               glue::glue('List instructions are missing for {list_ID}'))
  list_description <-
    list_info_row[[parts_sheet_column_names$part_description_column_name]]
  verify_input(list_description,
               glue::glue('List description is missing for {list_ID}'))
  
  list_display_info <- glue::glue(
    '## {list_label} {{ #{list_ID} }}
  <a href=\"/parts.html#{list_ID}\">({list_ID})</a>. {list_description} {if (list_instruction %!=na% constants$dictionary_missing_value_replacement) list_instruction else "" }'
  )
  
  list_elements_info_rows <-
    parts_table[parts_table[[parts_sheet_column_names$part_type_column_name]] == list_ID,]
  list_elements <-
    unique(list_elements_info_rows[[parts_sheet_column_names$part_ID_column_name]])
  list_elements_list <- list()
  for (element_ID in list_elements) {
    element_info <-
      list_elements_info_rows[list_elements_info_rows[[parts_sheet_column_names$part_ID_column_name]] == element_ID,]
    # Verify that parts contains the requested part information
    if (nrow(element_info) < 1) {
      warning(glue::glue('{element_ID} has no valid part info and is skipped'))
      next()
    }
    
    # Declare display elements
    element_label <-
      element_info[[parts_sheet_column_names$part_label_column_name]]
    element_description <-
      element_info[[parts_sheet_column_names$part_description_column_name]]
    element_status <-
      element_info[[parts_sheet_column_names$part_status_column_name]]
    element_first_released <-
      element_info[[parts_sheet_column_names$part_first_release_column_name]]
    element_last_updated <-
      element_info[[parts_sheet_column_names$part_last_updated_column_name]]
    
    # Verify display elements
    verify_input(element_label,
                 glue::glue('Part label is missing for {element_ID}'))
    verify_input(element_description,
                 glue::glue('Part description is missing for {element_ID}'))
    verify_input(element_status,
                 glue::glue('Part status is missing for {element_ID}'))
    verify_input(
      element_first_released,
      glue::glue('Part first released is missing for {element_ID}')
    )
    verify_input(element_last_updated,
                 glue::glue('Part last updates is missing for {element_ID}'))
    
    list_elements_list[[element_ID]] <-
      glue::glue(
        '**{element_label}** <a href=\"/parts.html#{element_ID}\">({element_ID})</a>. {element_description} </br>Status: {element_status}. First released: {element_first_released}. Last updated: {element_last_updated}.'
      )
  }
  list_of_lists[[list_ID]] <-
    create_html_list(list_display_info, list_elements_list)
}

# Create list for categorical displays
categories_list <- list()
categories_info_table <- sets_table[sets_table[[sets_sheet_column_names$part_set_type_column_name]] == constants$set_type_is_catSet, ]
unique_category_set_IDs <- unique(categories_info_table[[sets_sheet_column_names$part_set_ID_column_name]])
for (category_set_ID in unique_category_set_IDs) {
  category_info <- parts_table[parts_table[[parts_sheet_column_names$part_ID_column_name]]==category_set_ID, ]
  if (nrow(category_info) < 1) {
    warning(glue::glue('{category_set_ID} has no valid info in parts and is skipped'))
    next()
  }
  category_label <-
    category_info[[parts_sheet_column_names$part_label_column_name]]
  verify_input(category_label,
               glue::glue('Category label is missing for {category_set_ID}'))
  category_instruction <-
    category_info[[parts_sheet_column_names$part_instruction_column_name]]
  verify_input(
    category_instruction,
    glue::glue('Category instructions are missing for {category_set_ID}')
  )
  category_description <-
    category_info[[parts_sheet_column_names$part_description_column_name]]
  verify_input(category_description,
               glue::glue('Category description is missing for {category_set_ID}'))
  
  category_display <- glue::glue(
    '## {category_label} {{ #{category_set_ID} }}
                              <a href=\"/parts.html#{category_set_ID}\">({category_set_ID})</a>. {category_description} {if (category_instruction %!=na% constants$dictionary_missing_value_replacement) category_instruction else "" }')
  
  # Create category sub categories
  sub_categories_info_table <- categories_info_table[categories_info_table[[sets_sheet_column_names$part_set_ID_column_name]]== category_set_ID, ]
  unique_sub_categories_parts <- unique(sub_categories_info_table[[parts_sheet_column_names$part_ID_column_name]])
  sub_categories_list <- list()
  for (sub_category_ID in unique_sub_categories_parts) {
    sub_category_info <- parts_table[parts_table[[parts_sheet_column_names$part_ID_column_name]] == sub_category_ID, ]
    # Verify that parts contains the requested part information
    if (nrow(sub_category_info) < 1) {
      warning(glue::glue('{sub_category_ID} has no valid part info and is skipped'))
      next()
    }
    
    # Declare display elements
    sub_category_label <-
      sub_category_info[[parts_sheet_column_names$part_label_column_name]]
    sub_category_description <-
      sub_category_info[[parts_sheet_column_names$part_description_column_name]]
    sub_category_status <-
      sub_category_info[[parts_sheet_column_names$part_status_column_name]]
    sub_category_first_released <-
      sub_category_info[[parts_sheet_column_names$part_first_release_column_name]]
    sub_category_last_updated <-
      sub_category_info[[parts_sheet_column_names$part_last_updated_column_name]]
    
    # Verify display elements
    verify_input(sub_category_label,
                 glue::glue('Part label is missing for {sub_category_ID}'))
    verify_input(sub_category_description,
                 glue::glue('Part description is missing for {sub_category_ID}'))
    verify_input(sub_category_status,
                 glue::glue('Part status is missing for {sub_category_ID}'))
    verify_input(
      sub_category_first_released,
      glue::glue('Part first released is missing for {sub_category_ID}')
    )
    verify_input(sub_category_last_updated,
                 glue::glue('Part last updates is missing for {sub_category_ID}'))
    
    sub_categories_list[[sub_category_ID]] <-
      glue::glue(
        '**{sub_category_label}** <a href=\"/parts.html#{sub_category_ID}\">({sub_category_ID})</a>. {sub_category_description} </br>Status: {sub_category_status}. First released: {sub_category_first_released}. Last updated: {sub_category_last_updated}.'
      )
  }
  categories_list[[category_set_ID]] <-
    create_html_list(category_display, sub_categories_list)
  
}

# Combine sets and lists then sort on names of list
display_list <- append(sets_list, list_of_lists)
display_list <- append(display_list, categories_list)
display_list <- display_list[order(names(display_list))]

display <- paste(display_list, collapse = "\n")
```

`r display`
