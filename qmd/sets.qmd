---
project:
  execute-dir: ../
---

```{r setup, echo=FALSE}
knitr::opts_knit$set(root.dir = normalizePath("../"))
```

# Sets {.unnumbered}

{{< include _dictionary-version.qmd >}}

Sets are lists of categories and other parts. For example, `Collection category set` ([collectionCatSet](file:///Users/dmanuel/github/PHES-ODM-Doc/docs/sets.html#collectCatSet)) contains a list of the different collection types including: `Moore swab`, `Grab sample`, `Flow proportional sample`, etc.

Sets can have parts that are reused. For example, there are different quality measures for sample collection (e.g. `Sample not collected`), PCR measures (`Inhibition preset`), and sequencing measures (`Low depth of coverage`), but all quality sets share the `No quality concerns` indicator.

```{r, echo=FALSE, warning=FALSE}
# Utility Functions
# Source utility functions
source("R/qmd-utils.R")
# Source table formatting
source("R/format-table.R")
# Source warning utils
source("R/warning-utils.R")
source("R/template-utils.R")

# Display string templates
header_template <-
  '## {partLabel} {{ #{partID} }}
  <a href=\"/parts.html#{partID}\">({partID})</a>. {partDesc} {if (partInstr %!=na% constants$dictionary_missing_value_replacement) partInstr else "" }'

set_sub_header_template <- '<a href=\"/parts.html#{partID}\">({partID})</a>{partDesc} \\
{if(partInstr %!=na% constants$dictionary_missing_value_replacement) partInstr else ""} </br>
Status: {status}. First Released: {firstReleased}. \\
Last updated: {lastUpdated}.'

part_bullet_template <- '**{partLabel}** <a href=\"/parts.html#{partID}\">({partID})</a>. {partDesc} </br>Status: {status}. First released: {firstReleased}. Last updated: {lastUpdated}.'


# Extract, format and order sets table on set type
sets_table_source <-
  readxl::read_excel(
    file.path(
      getwd(),
      constants$dictionary_directory,
      dictionary_full_file_name
    ),
    sheet = constants$sets_sheet_name
  )
sets_table <- format_table(sets_table_source)
sets_table <-
  sets_table[order(sets_table[[sets_sheet_column_names$part_set_type_column_name]]),]

# Generate and format parts table
parts_table_source <-
  readxl::read_excel(
    file.path(
      getwd(),
      constants$dictionary_directory,
      dictionary_full_file_name
    ),
    sheet = constants$parts_sheet_name
  )
parts_table <-
  format_table(parts_table_source,
               parts_sheet_column_names,
               remove_duplicate = TRUE)

# Declare list to store sets
sets_list <- list()

# Find then loop over unique setTypes
unique_set_types <-
  unique(sets_table[[sets_sheet_column_names$part_set_type_column_name]])
for (set_type in unique_set_types) {
  # Removing dictSet set type and catSet
  if (set_type == constants$set_type_is_dictSet || set_type == constants$set_type_is_catSet) {
    next()
  }
  
  # Create header for setType
  set_type_info <-
    parts_table[parts_table[[parts_sheet_column_names$part_ID_column_name]] == set_type,]
  # Issue warning and skip if no matching information on setType is found in parts
  if (nrow(set_type_info) < 1) {
    warning(skipped_and_missing(set_type))
    next()
  }
  
  #
  set_header_input <- list()
  set_header_input[["partID"]] <- set_type
  set_header_input[["partLabel"]] <-
    set_type_info[[parts_sheet_column_names$part_label_column_name]]
  set_header_input[["partInstr"]] <-
    set_type_info[[parts_sheet_column_names$part_instruction_column_name]]
  set_header_input[["partDesc"]] <-
    set_type_info[[parts_sheet_column_names$part_description_column_name]]
  
  set_display <- generate_display(header_template, set_header_input, set_type)
  
  # Find and loop over unique setID according to set_type
  rows_for_current_set_type <-
    sets_table[sets_table[[sets_sheet_column_names$part_set_type_column_name]] == set_type, ]
  unique_set_IDs <-
    unique(rows_for_current_set_type[[sets_sheet_column_names$part_set_ID_column_name]])
  unique_set_IDs <- sort(unique_set_IDs)
  for (set_ID in unique_set_IDs) {
    set_ID_info <-
      parts_table[parts_table[[parts_sheet_column_names$part_ID_column_name]] == set_ID,]
    # Handle no rows found for set_ID in parts
    if (nrow(set_ID_info) < 1) {
      warning(skipped_and_missing(set_ID))
      next()
    }
    set_ID_part_label <-
      set_ID_info[[parts_sheet_column_names$part_label_column_name]]
    # Create set_ID subsection
    set_display <- verify_and_append_content(
      set_display,
      set_ID_part_label,
      missing_warning(
        "Set Label", set_ID
      ),
      glue::glue('\n\n
      ### {set_ID_part_label} {{ #{set_ID} }}'),
      glue::glue('\n\n
                 ### {set_ID}')
    )
    # Declare additional setID display
    set_ID_input <- list()
    set_ID_input[["partID"]] <- set_ID
    set_ID_input[["partDesc"]] <- set_ID_info[[parts_sheet_column_names$part_description_column_name]]
    set_ID_input[["partInstr"]] <- set_ID_info[[parts_sheet_column_names$part_instruction_column_name]]
    set_ID_input[["status"]] <- set_ID_info[[parts_sheet_column_names$part_status_column_name]]
    set_ID_input[["firstReleased"]] <- set_ID_info[[parts_sheet_column_names$part_first_release_column_name]]
    set_ID_input[["lastUpdated"]] <- set_ID_info[[parts_sheet_column_names$part_last_updated_column_name]]
    
    
    set_display <- glue::glue(
      '{set_display}
      {generate_display(set_sub_header_template, set_ID_input, set_ID)}')
    
    # Create list to hold a values for html list
    list_values <- list()
    
    # Find and loop over unique partID according to set_ID
    current_set_ID_rows <-
      rows_for_current_set_type[rows_for_current_set_type[[sets_sheet_column_names$part_set_ID_column_name]] == set_ID, ]
    unique_part_IDs <-
      unique(current_set_ID_rows[[parts_sheet_column_names$part_ID_column_name]])
    unique_part_IDs <- sort(unique_part_IDs)
    for (part_ID in unique_part_IDs) {
      part_info <-
        parts_table[parts_table[[parts_sheet_column_names$part_ID_column_name]] == part_ID, ]
      # Verify that parts contains the requested part information
      if (nrow(part_info) < 1) {
        warning(
          skipped_and_missing(part_ID)
        )
        next()
      }
      
      
      list_values[[length(list_values) + 1]] <-
        bullet_point_template_population(part_info, part_ID, part_bullet_template)
      
    }
    set_display <- create_html_list(set_display, list_values)
  }
  sets_list[[set_type]] <- set_display
}

# Create lists
list_set_rows <-
  sets_table[sets_table[[sets_sheet_column_names$part_set_ID_column_name]] == constants$set_ID_is_list_set,]
unique_list_part_IDs <-
  unique(list_set_rows[[parts_sheet_column_names$part_ID_column_name]])

# Create list to store lists
list_of_lists <- list()

for (list_ID in unique_list_part_IDs) {
  list_info_row <-
    parts_table[parts_table[[parts_sheet_column_names$part_ID_column_name]] ==
                  list_ID,]
  # Verify that parts contains the requested part information
  if (nrow(list_info_row) < 1) {
    warning(skipped_and_missing(list_ID))
    next()
  }
  list_input <- list()
  list_input[["partID"]] <- list_ID
  list_input[["partLabel"]] <-
    list_info_row[[parts_sheet_column_names$part_label_column_name]]
  list_input[["partInstr"]] <-
    list_info_row[[parts_sheet_column_names$part_instruction_column_name]]
  list_input[["partDesc"]] <-
    list_info_row[[parts_sheet_column_names$part_description_column_name]]
  
  list_display_info <- generate_display(header_template, list_input, list_ID)
   
  
  list_elements_info_rows <-
    parts_table[parts_table[[parts_sheet_column_names$part_type_column_name]] == list_ID,]
  list_elements <-
    unique(list_elements_info_rows[[parts_sheet_column_names$part_ID_column_name]])
  list_elements_list <- list()
  for (element_ID in list_elements) {
    element_info <-
      list_elements_info_rows[list_elements_info_rows[[parts_sheet_column_names$part_ID_column_name]] == element_ID,]
    # Verify that parts contains the requested part information
    if (nrow(element_info) < 1) {
      warning(skipped_and_missing(element_ID))
      next()
    }
    
    list_elements_list[[element_ID]] <-
      bullet_point_template_population(element_info, element_ID, part_bullet_template)
  }
  list_of_lists[[list_ID]] <-
    create_html_list(list_display_info, list_elements_list)
}

# Create list for categorical displays
categories_list <- list()
categories_info_table <- sets_table[sets_table[[sets_sheet_column_names$part_set_type_column_name]] == constants$set_type_is_catSet, ]
unique_category_set_IDs <- unique(categories_info_table[[sets_sheet_column_names$part_set_ID_column_name]])
for (category_set_ID in unique_category_set_IDs) {
  category_info <- parts_table[parts_table[[parts_sheet_column_names$part_ID_column_name]]==category_set_ID, ]
  if (nrow(category_info) < 1) {
    warning(skipped_and_missing(category_set_ID))
    next()
  }
  
  category_input <- list()
  category_input[["partID"]] <- category_set_ID
  category_input[["partLabel"]] <-
    category_info[[parts_sheet_column_names$part_label_column_name]]
  category_input[["partInstr"]] <-
    category_info[[parts_sheet_column_names$part_instruction_column_name]]
  category_input[["partDesc"]] <-
    category_info[[parts_sheet_column_names$part_description_column_name]]
  
  category_display <- generate_display(header_template, category_input, category_set_ID)
  
  # Create category sub categories
  sub_categories_info_table <- categories_info_table[categories_info_table[[sets_sheet_column_names$part_set_ID_column_name]]== category_set_ID, ]
  unique_sub_categories_parts <- unique(sub_categories_info_table[[parts_sheet_column_names$part_ID_column_name]])
  sub_categories_list <- list()
  for (sub_category_ID in unique_sub_categories_parts) {
    sub_category_info <- parts_table[parts_table[[parts_sheet_column_names$part_ID_column_name]] == sub_category_ID, ]
    # Verify that parts contains the requested part information
    if (nrow(sub_category_info) < 1) {
      warning(skipped_and_missing(sub_category_ID))
      next()
    }
    
    sub_categories_list[[sub_category_ID]] <-
      bullet_point_template_population(sub_category_info, sub_category_ID, part_bullet_template)
  }
  categories_list[[category_set_ID]] <-
    create_html_list(category_display, sub_categories_list)
  
}

# Combine sets and lists then sort on names of list
display_list <- append(sets_list, list_of_lists)
display_list <- append(display_list, categories_list)
display_list <- display_list[order(names(display_list))]

display <- paste(display_list, collapse = "\n")
```

`r display`
